name: Auto Release to Remote Repositories

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set Up Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

      # 克隆目标仓库
      - name: Checkout Target Repository
        uses: actions/checkout@v4
        with:
          repository: footprintcat/admin-template-release
          token: ${{ secrets.TARGET_REPO_TOKEN }}
          path: target-repo
          fetch-depth: 0

      # - name: Add Gitee Remote
      #   run: |
      #     cd target-repo
      #     # 添加Gitee远端
      #     git remote add gitee https://${{ secrets.GITEE_ACCESS_TOKEN }}:${{ secrets.GITEE_PASSWORD }}@gitee.com/footprintcat/admin-template-release.git

      - name: Pull Latest Changes from Target Repositories
        run: |
          cd target-repo
          # 拉取GitHub仓库最新代码
          git pull origin main || true
          # # 拉取Gitee仓库最新代码（可选，确保两边代码同步）
          # git pull gitee main || true

      - name: Generate Changelog
        id: changelog
        run: |
          # 获取当前tag
          CURRENT_TAG=$(git describe --tags --abbrev=0)

          # 获取上一个tag，如果没有则获取所有提交
          PREV_TAG=$(git describe --tags --abbrev=0 $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

          # 生成Changelog
          if [ -z "$PREV_TAG" ]; then
            # 没有上一个tag，获取所有提交
            CHANGELOG=$(git log --pretty=format:"- %s" --reverse)
          else
            # 有上一个tag，获取两个tag之间的提交
            CHANGELOG=$(git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s" --reverse)
          fi

          # 格式化Changelog
          NEW_CHANGELOG="# $CURRENT_TAG\n\n$CHANGELOG"

          # 输出Changelog到文件
          # 检查是否存在旧的CHANGELOG.md文件
          if [ -f target-repo/CHANGELOG.md ]; then
            # 读取旧的CHANGELOG内容（保留所有内容，除了首行的# Changelog和可能的空行）
            OLD_CHANGELOG=$(tail -n +2 target-repo/CHANGELOG.md || true)
            # 新的CHANGELOG内容（添加主标题和新条目，然后是旧条目）
            echo -e "# Changelog\n\n$NEW_CHANGELOG\n\n$OLD_CHANGELOG" > CHANGELOG.md
          else
            # 没有旧文件，直接创建新的CHANGELOG
            echo -e "# Changelog\n\n$NEW_CHANGELOG" > CHANGELOG.md
          fi

          # 输出到环境变量（保持与文件内容一致的格式）
          echo "CHANGELOG<<EOF" >> $GITHUB_ENV
          echo -e "# Changelog\n\n# $CURRENT_TAG\n\n$CHANGELOG" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Update Source Code in Target Repository
        run: |
          # 确保项目目录存在
          mkdir -p target-repo/admin-backend
          mkdir -p target-repo/admin-frontend
          mkdir -p target-repo/admin-mobile
          mkdir -p target-repo/docs
          mkdir -p target-repo/sql

          # 复制项目代码到目标仓库，覆盖现有文件
          cp -r -a admin-backend/. target-repo/admin-backend/
          cp -r -a admin-frontend/. target-repo/admin-frontend/
          cp -r -a admin-mobile/. target-repo/admin-mobile/
          # cp -r -a docs/. target-repo/docs/
          rsync -av --exclude='internal' docs/ target-repo/docs/
          cp -r -a sql/. target-repo/sql/

          # 复制Changelog文件
          cp CHANGELOG.md target-repo/

          # 复制必要的根目录文件
          cp README.md target-repo/ 2>/dev/null || true
          cp LICENSE target-repo/ 2>/dev/null || true
          cp .editorconfig target-repo/ 2>/dev/null || true
          cp .gitattributes target-repo/ 2>/dev/null || true
          cp .gitignore target-repo/ 2>/dev/null || true
          cp package.json target-repo/ 2>/dev/null || true

          # 从replace-file目录复制文件到目标仓库根目录，覆盖现有文件
          cp -r -a .github/workflows/replace-file/. target-repo/ 2>/dev/null || true

      - name: Commit and Push to Target Repositories
        run: |
          cd target-repo

          # 添加所有文件
          git add .

          # 检查是否有改动
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            # 提交代码
            git commit -m "Release ${{ github.ref_name }}: Auto release from source repository"

            # 推送到GitHub
            # git push origin main
            git push https://x-access-token:${{ secrets.TARGET_REPO_TOKEN }}@github.com/footprintcat/admin-template-release.git main

            # # 推送到Gitee
            # git push gitee main
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean Up
        run: rm -rf target-repo CHANGELOG.md
